2. **Relation MTO/OTM entre deux classes enfants**
Nous considérons que Fruits est propriétaire de la relation et arbre son inverse. Il se peut qu'un arbre contiennent plusieurs ou aucun fruit. 

>    //src/Entity/Fruit
>    
>   /**
>    
>    *@ORM\ManyToOne(targetEntity="Arbre", inversedBy="fruits")
>
>    *@ORM\JoinColumn(nullable=false)
>
>    */
>    
>    private $arbre;

>    //src/Entity/Arbre  
>   /**
>   
>    *@ORM\OneToMany(targetEntity="Fruit", mappedBy="arbre")
>    
>    */
>    
>   private $fruits;

Nous travaillons dans le controller fruit et nous voulons renvoyer les données concernant les arbres et les fruits dans la page des fruits.

- Dans un premier temps nous pouvons utiliser la méthode findAll() pour récupérer tous les objets Fruit. Pour récupérer tout les objets Arbre, nous faisons une boucle et passons les données dans un tableau arbre grâce à la méthode $fruit->getArbre().
public function indexAction(FruitRepository $fruitrepo)

>    // src/Controller/FruitController
>    {
>    
>       $fruits = $fruitrepo->findAll();
>       
>       $arbres = [];
>       foreach ($fruits as $fruit) {
>           $arbres[] = $fruit->getArbre();
>       }
>       
>       return $this->render('fruit/index.html.twig', [
>          'fruits' => $fruits,
>          'arbres' => $arbres
>       ]);
>    }

- Encore une fois merci lazyLoading, mon app bat un record de 42 requêtes ! Ceci Fruit et Arbre sont associés à Mangeur et Jardinnier par la classe parente Vegétal.Je peux utiliser sans difficultée la relation dans mon template.

>   // Template/Fruit/index.html.twig
>   <p>
>   
>       Mangeur: {{ fruit.mangeur.fullName }}
>       
>   </p>
>   
>   <p> Jardinniers: 
>   
>       {% for jardinier in fruit.jardiniers %}
>       
>           {{ jardinier.fullName }}
>           
>       {% endfor %}
>       
>   </p>
...
>   {% for arbre in arbres %}
>       <div class="col-md-4">
>           <h3>{{ arbre.nom }}</h3>
>           <p>{{ arbre.description }}</p>
>           <p>
>               {% for jardinier in arbre.jardiniers %}
>                   cultivé par : {{ jardinier.nom }}
>               {% endfor %}    
>           </p>
>           <p>
>               <ul>
>                   {% for fruit in arbre.fruits %}
>                       <li>{{ fruit.nom }} 
>                           mangé par {{ fruit.mangeur.nom }}
>                       {% for jardinier in fruit.jardiniers %}
>                           cultivé par {{ jardinier.nom }}
>                       {% endfor %}    
>                       </li>
>                   {% endfor %}
>               </ul>
>           </p>
>       </div>
>   {% endfor %}

- Pour affiner le nombre de mes requêtes, j'ai la possibilité d'utiliser le queryBuilder d'utiliser les méthodes join , innerJoin ou leftJoin.

>   // src/Reposory/FruitRepository
>   public function giveMeAllFruit()
>   
>       {
>       
>           return $this->createQueryBuilder('f')
>           
>               ->innerJoin('f.arbre', 'a')
>               
>               ->addSelect('a')
>               
>               ->innerJoin('f.mangeur', 'm')
>               
>               ->addSelect('m')
>               
>               ->leftJoin('f.jardiniers', 'j')
>               
>               ->addSelect('j')
>               
>               ->orderBy('f.id', 'ASC')
>               
>               ->setMaxResults(10)
>               
>               ->getQuery()
>               
>               ->getResult();
>               
>       }

- Toujours dans FruitRepository  j'ai la possibilité d'utiliser le langage dql pour récupérer les objets Arbres. En DQL, je suis obligée d'utilisée 'INSTANCE OF' dans la condition WHERE.
>   // src/Reposory/FruitRepository
>   
>   public function giveMeAllArbresDQL(): array
>   
>       {
>       
>           $entityManager = $this->getEntityManager();
>           
>           $query = $entityManager->createQuery(
>           
>               "SELECT a, f, am, aj, fm, fj
>               
>               FROM App\Entity\Arbre a
>               
>               JOIN a.fruits f
>               
>               JOIN a.jardiniers aj
>               
>               JOIN a.mangeur am
>               
>               JOIN f.mangeur fm
>               
>               JOIN f.jardiniers fj
>               
>               WHERE a INSTANCE OF App\Entity\Vegetal
>               
>               AND f INSTANCE OF App\Entity\Vegetal "
>               
>           );
>           
>           // returns an array of objects
>           
>           return $query->execute();
>           
>       }

Ce qui reduit grandement le nombre de reqêtes (2) !

**CCL: Ici aussi l'heritage de classe fait son travail en background !**





